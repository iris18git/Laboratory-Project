'''

if __name__ == "__main__":
    # Read the point cloud data
    # point_cloud = pd.read_csv("point_cloud_data_sample.xyz", delimiter=" ", nrows=500)

    points = pd.read_csv('PointData0.csv')


    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    #ax = fig.add_subplot()

    x = points[(points.columns)[0]].values
    y = points[(points.columns)[1]].values
    z = points[(points.columns)[2]].values

    points = np.array(list(zip(x,y)))

    ax.scatter(x,y,c='r')

    plt.show()
'''

from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from scipy.stats import multivariate_normal
import pandas as pd

point_cloud = pd.read_csv("point_cloud_data_sample.xyz", delimiter=" ", nrows=500)

points = pd.read_csv('PointData0.csv')

x = points[(points.columns)[0]].values
y = points[(points.columns)[1]].values
z = points[(points.columns)[2]].values

points_3d = np.array(list(zip(x, y, z)))
points_2d = np.array(list(zip(x, y)))

# Sample parameters
mu = np.mean(points_2d, axis=0)
print(mu)
sigma = np.cov(np.stack((x, y)))
print(sigma)
rv = multivariate_normal(mu, sigma)

# Bounds parameters
x_abs = 2.5
y_abs = 2.5
x_grid, y_grid = np.mgrid[-x_abs:x_abs:.02, -y_abs:y_abs:.02]

pos = np.empty(x_grid.shape + (2,))
pos[:, :, 0] = x_grid
pos[:, :, 1] = y_grid

levels = np.linspace(0, 1, 40)

fig = plt.figure()
ax = fig.gca(projection='3d')

# Removes the grey panes in 3d plots
ax.xaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))
ax.yaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))
ax.zaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))

# The heatmap
ax.contourf(x_grid, y_grid, 0.1 * rv.pdf(pos),
            zdir='z', levels=0.1 * levels, alpha=0.9)

# The wireframe
ax.plot_wireframe(x_grid, y_grid, rv.pdf(
    pos), rstride=10, cstride=10, color='k')

# The scatter. Note that the altitude is defined based on the pdf of the
# random variable
ax.scatter(points_2d[:, 0], points_2d[:, 1], 1.1 * rv.pdf(points_2d), c='r')

points_2d_1 = enumerate(list(points_2d))
door_point_idx, door_point = min(points_2d_1, key=lambda pair: rv.pdf(pair[1]))

ax.scatter(door_point[0], door_point[1], c='g', s=1000)

ax.legend()
ax.set_title("Find lowest point of the gaussian")
ax.set_xlim3d(-x_abs, x_abs)
ax.set_ylim3d(-y_abs, y_abs)
ax.set_zlim3d(0, 1)

plt.show()
